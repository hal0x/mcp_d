# Shell MCP Server - Архитектура и Руководство

## Обзор проекта

**Shell MCP** — это MCP сервер для выполнения кода в изолированных Docker контейнерах, предоставляющий безопасную среду для выполнения произвольного кода.

## Архитектура

### Структура проекта
```
shell-mcp/
├── src/shell_mcp/         # Основной код
│   ├── config.py          # Конфигурация и настройки
│   ├── server.py          # Главный MCP сервер
│   ├── services/          # Сервисы
│   │   ├── docker_executor.py  # Docker исполнитель
│   │   └── script_store.py     # Хранилище скриптов
│   └── tools/             # Инструменты
│       ├── meta.py        # Мета-инструменты
│       └── run.py         # Инструменты выполнения
├── examples/              # Примеры использования
├── pyproject.toml         # Конфигурация проекта
└── README.md              # Документация
```

### Компоненты системы

#### 1. MCP Server (`server.py`)
- **Назначение**: Главная точка входа MCP сервера
- **Функции**: 
  - Регистрация инструментов (tools)
  - Обработка вызовов инструментов
  - Поддержка stdio и HTTP транспортов
- **Паттерны**: FastMCP, декораторы для инструментов

#### 2. Configuration (`config.py`)
- **Назначение**: Управление конфигурацией приложения
- **Функции**:
  - Загрузка переменных окружения
  - Настройки Docker
  - Параметры безопасности
- **Паттерны**: Pydantic Settings, валидация

#### 3. Docker Executor (`services/docker_executor.py`)
- **Назначение**: Выполнение кода в Docker контейнерах
- **Функции**:
  - Создание и управление контейнерами
  - Выполнение кода
  - Очистка ресурсов
- **Паттерны**: Docker API, Resource Management

#### 4. Script Store (`services/script_store.py`)
- **Назначение**: Хранение и управление скриптами
- **Функции**:
  - Сохранение скриптов
  - Загрузка скриптов
  - Управление версиями
- **Паттерны**: File System, Versioning

#### 5. Tools (`tools/`)
- **Назначение**: MCP инструменты для выполнения кода
- **Функции**:
  - `run_code_simple` - простое выполнение кода
  - `run_code_multi_step` - многошаговое выполнение
  - `run_scripts_batch` - последовательный запуск нескольких сохранённых скриптов
  - `delete_saved_scripts` / `promote_temp_scripts` - групповое управление хранилищем
  - Планировщик: schedule_saved_script, list_scheduled_scripts, cancel_scheduled_script
  - Мета-инструменты для управления
- **Паттерны**: Tool Registration, Error Handling

## Принципы разработки

### 1. Безопасность
- **Изоляция**: Каждое выполнение в отдельном контейнере
- **Ограничения**: Лимиты ресурсов (CPU, память, время)
- **Очистка**: Автоматическая очистка контейнеров
- **Сеть**: Контролируемый доступ к сети

### 2. Производительность
- **Кэширование**: Кэширование образов Docker
- **Пул контейнеров**: Переиспользование контейнеров
- **Параллелизм**: Поддержка параллельных выполнений
- **Оптимизация**: Минимизация времени запуска

### 3. Надежность
- **Обработка ошибок**: Graceful handling всех ошибок
- **Таймауты**: Защита от зависших процессов
- **Логирование**: Детальное логирование операций
- **Мониторинг**: Отслеживание использования ресурсов

### 4. Расширяемость
- **Плагины**: Поддержка различных языков программирования
- **Конфигурация**: Гибкая настройка параметров
- **API**: Программный интерфейс для интеграции
- **Метрики**: Сбор метрик производительности

## Инструменты (Tools)

### Основные инструменты:

#### 1. `run_code_simple`
- **Назначение**: Выполнение простого кода
- **Параметры**: code, language, image, dependencies
- **Возвращает**: Результат выполнения
- **Безопасность**: Изоляция в контейнере

#### 2. `run_code_multi_step`
- **Назначение**: Многошаговое выполнение кода
- **Параметры**: steps, dependencies, environment
- **Возвращает**: Результаты всех шагов
- **Особенности**: Сохранение состояния между шагами

#### 3. Мета-инструменты
- **Назначение**: Управление сервером
- **Функции**: health, version, list_saved_scripts
- **Использование**: Мониторинг и диагностика

#### 4. `run_scripts_batch`
- **Назначение**: Запуск нескольких сохранённых скриптов подряд одной командой
- **Параметры**: массив `scripts`, где каждый элемент повторяет аргументы `run_saved_script`
- **Возвращает**: Список результатов с полями `success`, `result` или `error`
- **Особенности**: Ошибки по отдельным скриптам не останавливают остальные

#### 5. Батч-управление скриптами
- **`delete_saved_scripts`**: Удаляет сразу несколько постоянных скриптов
- **`promote_temp_scripts`**: Переводит выбранные временные скрипты в постоянные
- **Возвращают**: Список статусов с указанием успешности каждой операции

#### 6. Планировщик сохранённых скриптов
- **`schedule_saved_script`**: Плановое выполнение скрипта (по времени или через задержку); поддерживает повтор с интервалом
- **`list_scheduled_scripts`**: Показывает активные и завершённые задания с последним статусом
- **`cancel_scheduled_script`**: Отменяет запланированный запуск по идентификатору

### Паттерны инструментов:
- **Валидация входных данных**: Проверка кода и параметров
- **Безопасность**: Изоляция выполнения
- **Обработка ошибок**: Понятные сообщения об ошибках
- **Логирование**: Детальное логирование операций

### Стандарт описания инструментов
- **Формат**: первое предложение ≤90 символов, глагол в настоящем времени (например, *Executes*, *Returns*).
- **Язык**: только английский; docstring используется FastMCP для генерации описания в `list_tools`.
- **Структура**: детали, примеры и подсказки идут со второго предложения/абзаца, чтобы не перегружать выдачу.
- **Ссылка на код**: поддерживаем стиль в `tools/meta.py` и `tools/run.py`, новые инструменты следуют тем же правилам.

### Документация инструментов (best practices)
- Явно описывайте взаимоисключающие параметры: подчёркивайте, что `code` XOR `script_path` и что хотя бы один нужен.
- Показывайте рабочие примеры вызова: отдельные блоки кода с примером `run_code_simple(...)` или `run_code_multi_step(...)` помогают избежать неверного формата.
- Указывайте формат сложных полей: `env` как список `KEY=VALUE`, `steps` как массив строк, `dependencies` – список пакетов.
- Фиксируйте требования к ресурсам: добавляйте примеры/regex для `memory` (`256m`, `1g`) и `cpus` (`0.5`, `2`).
- Добавляйте подсказки и шаблоны: краткие bullet tips (как переключиться на bash, как добавить зависимости, как устроить многошаговый сценарий) экономят время пользователям.
- Для JavaScript/Node используйте `language="node"` — по умолчанию будет выбран образ `node:20-slim`; при необходимости переопределяйте `image` и `command`.
- Troubleshooting: перечисляйте частые ошибки (пустой `steps`, неправильный формат `env`, отсутствие `records`).

## Конфигурация

### Переменные окружения:
```bash
# Docker настройки
SHELL_MCP_DEFAULT_IMAGE=python:3.11
SHELL_MCP_DEFAULT_NETWORK=false
SHELL_MCP_DEFAULT_MEMORY=512m
SHELL_MCP_DEFAULT_CPUS=1

# Безопасность
SHELL_MCP_TIMEOUT_SECONDS=120
SHELL_MCP_MAX_CONTAINERS=10
SHELL_MCP_CLEANUP_INTERVAL=300

# Сервер
HOST=0.0.0.0
PORT=8070
LOG_LEVEL=INFO
```

### Настройки безопасности:
- **Таймауты**: Максимальное время выполнения
- **Ресурсы**: Лимиты CPU и памяти
- **Сеть**: Контроль сетевого доступа
- **Файловая система**: Ограничения доступа к файлам

## Тестирование

### Структура тестов:
```
tests/
├── test_docker_executor.py    # Тесты Docker исполнителя
├── test_script_store.py       # Тесты хранилища скриптов
├── test_tools.py             # Тесты инструментов
└── test_integration.py       # Интеграционные тесты
```

### Принципы тестирования:
- **Unit тесты**: Для каждого компонента
- **Интеграционные тесты**: Для Docker интеграции
- **Тесты безопасности**: Проверка изоляции
- **Тесты производительности**: Нагрузочное тестирование

## Развертывание

### Требования:
- Docker Engine
- Python 3.10+
- Достаточно ресурсов для контейнеров

### Установка:
```bash
# Установка зависимостей
pip install -e .

# Запуск в stdio режиме
python -m shell_mcp.server

# Запуск в HTTP режиме
python -m shell_mcp.server --host 0.0.0.0 --port 8000
```

### Docker Compose развертывание

#### Пересборка и перезапуск после изменений кода

**⚠️ ВАЖНО**: После внесения изменений в код необходимо пересобрать контейнер и перезапустить сервис:

```bash
# Пересборка контейнера с изменениями кода
docker-compose -f ../../infra/docker-compose.mcp.yml build shell-mcp

# Перезапуск сервиса с новым образом
docker-compose -f ../../infra/docker-compose.mcp.yml up -d shell-mcp

# Проверка статуса сервиса
docker-compose -f ../../infra/docker-compose.mcp.yml ps shell-mcp

# Просмотр логов для диагностики
docker-compose -f ../../infra/docker-compose.mcp.yml logs -f shell-mcp
```

#### Полная пересборка всех сервисов

```bash
# Пересборка всех MCP сервисов
docker-compose -f ../../infra/docker-compose.mcp.yml build

# Перезапуск всех сервисов
docker-compose -f ../../infra/docker-compose.mcp.yml up -d

# Проверка статуса всех сервисов
docker-compose -f ../../infra/docker-compose.mcp.yml ps
```

#### Отладка и диагностика

```bash
# Вход в контейнер для отладки
docker-compose -f ../../infra/docker-compose.mcp.yml exec shell-mcp bash

# Проверка переменных окружения в контейнере
docker-compose -f ../../infra/docker-compose.mcp.yml exec shell-mcp env

# Проверка доступности сервиса
curl http://localhost:8070/health
```

#### Очистка и пересборка с нуля

```bash
# Остановка и удаление контейнеров
docker-compose -f ../../infra/docker-compose.mcp.yml down

# Удаление образов (принудительная пересборка)
docker-compose -f ../../infra/docker-compose.mcp.yml build --no-cache shell-mcp

# Запуск с чистого листа
docker-compose -f ../../infra/docker-compose.mcp.yml up -d shell-mcp
```

### Docker Compose:
```yaml
version: '3.8'
services:
  shell-mcp:
    build: .
    ports:
      - "8000:8000"
    environment:
      - SHELL_MCP_DEFAULT_IMAGE=python:3.11
      - SHELL_MCP_DEFAULT_NETWORK=false
    volumes:
      - /var/run/docker.sock:/var/run/docker.sock
```

## Мониторинг и логирование

### Логирование:
- **Уровни**: DEBUG, INFO, WARNING, ERROR
- **Контекст**: ID контейнера, время выполнения
- **Метрики**: Использование ресурсов, время выполнения

### Мониторинг:
- **Health check**: Статус сервера и Docker
- **Метрики**: Количество контейнеров, использование ресурсов
- **Алерты**: Превышение лимитов, ошибки выполнения

## Безопасность

### Принципы:
1. **Изоляция**: Каждое выполнение изолировано
2. **Ограничения**: Лимиты ресурсов и времени
3. **Очистка**: Автоматическая очистка контейнеров
4. **Мониторинг**: Отслеживание подозрительной активности

### Рекомендации:
- Используйте минимальные образы Docker
- Настройте строгие лимиты ресурсов
- Регулярно обновляйте базовые образы
- Мониторьте использование ресурсов

## Развитие проекта

### Приоритеты:
1. **Безопасность**: Улучшение изоляции и контроля
2. **Производительность**: Оптимизация запуска контейнеров
3. **Функциональность**: Поддержка новых языков
4. **Мониторинг**: Расширенная аналитика

### Roadmap:
- [ ] Поддержка GPU контейнеров
- [ ] Веб-интерфейс для мониторинга
- [ ] Интеграция с Kubernetes
- [ ] Поддержка распределенного выполнения
- [ ] Расширенная аналитика использования

## Документация и отчёты

### ⚠️ ВАЖНО: Правила работы с документацией

**НЕ СОЗДАВАЙТЕ .md файлы отчёты каждый раз!**

- **НЕ создавайте** новые .md файлы для каждого изменения или отчёта
- **НЕ создавайте** файлы типа `REPORT_2024.md`, `CHANGES.md`, `UPDATE.md` и т.п.
- **НЕ дублируйте** информацию в разных файлах

### Ведение changelog:

**ВСЕГДА обновляйте существующие файлы:**

1. **`CHANGELOG.md`** - основной файл для записи изменений
2. **`README.md`** - обновляйте при значительных изменениях
3. **`AGENTS.md`** - обновляйте при изменениях архитектуры
4. **Существующие .md файлы** - дополняйте, не создавайте новые

### Формат changelog:
```markdown
## [Версия] - YYYY-MM-DD

### Добавлено
- Новая функциональность

### Изменено
- Изменения в существующей функциональности

### Исправлено
- Исправления ошибок

### Удалено
- Удаленная функциональность
```

### Принципы:
- **Консолидация**: Вся информация в существующих файлах
- **Обновление**: Редактируйте существующие файлы
- **Структурированность**: Используйте единый формат
- **Отслеживаемость**: Все изменения в changelog

## Качество кода и стандарты

### Code Review
- **Review guidelines**: Обязательный код-ревью для всех изменений
- **Automated checks**: Автоматические проверки через CI/CD
- **Code coverage**: Минимум 80% покрытия кода тестами
- **Security review**: Особое внимание к безопасности выполнения кода

### Документация кода
- **API documentation**: Полная документация всех инструментов
- **Code comments**: Комментарии для сложной логики Docker
- **Type hints**: Обязательные аннотации типов для всех функций
- **Docstrings**: Строки документации для всех публичных методов

### Стандарты кодирования
- **PEP 8**: Строгое соблюдение стандартов Python
- **Black**: Автоматическое форматирование кода (длина строки 88)
- **Ruff**: Линтинг кода с правилами E, F, I
- **MyPy**: Строгая проверка типов (strict mode)

### Инструменты качества
```bash
# Форматирование кода
black .

# Линтинг
ruff check .

# Проверка типов
mypy .

# Тестирование
pytest tests/ --cov=src --cov-report=html

# Проверка безопасности
bandit -r src/
safety check
```

### Принципы разработки
- **SOLID принципы**: Следование принципам объектно-ориентированного дизайна
- **DRY**: Не повторяйся - избегание дублирования кода
- **KISS**: Простота и понятность кода
- **Security first**: Безопасность превыше всего

### Структура коммитов
- **Conventional Commits**: Использование стандартного формата
- **Prefixes**: `feat:`, `fix:`, `docs:`, `test:`, `refactor:`, `perf:`, `security:`
- **Scope**: Указание области изменений
- **Breaking changes**: Явное указание критических изменений

### Примеры коммитов:
```bash
feat(docker): добавить поддержку GPU контейнеров
fix(executor): исправить утечку памяти в контейнерах
docs(readme): обновить инструкции по безопасности
test(services): добавить тесты для DockerExecutor
refactor(config): упростить конфигурацию Docker
perf(containers): оптимизировать время запуска контейнеров
security(docker): ужесточить политики безопасности
```
