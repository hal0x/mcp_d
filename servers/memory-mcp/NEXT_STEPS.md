# План следующих шагов по улучшению качества поиска

## Текущий статус

### ✅ Выполнено

1. **Ранжирование исправлено** ✅
   - Веса FTS5/ChromaDB скорректированы
   - Scores различаются, релевантные результаты в топе

2. **Поиск улучшен** ✅
   - Добавлена фильтрация стоп-слов
   - Поиск находит существующие записи

3. **Эмбеддинги работают** ✅
   - 100% покрытие
   - Возвращаются в результатах

4. **Графовые связи работают** ✅
   - API возвращает соседей корректно

5. **Fetch record работает** ✅
   - Возвращает записи с эмбеддингами

6. **Qdrant настроен** ✅ (2025-11-18)
   - Добавлен `QDRANT_URL=http://localhost:6333` в `.env`
   - Qdrant подключен и работает
   - Векторный поиск готов к использованию

7. **RRF реализован** ✅ (2025-11-18)
   - Реализован метод `_reciprocal_rank_fusion()` для объединения результатов
   - Добавлен boost 20% для точных совпадений в FTS5 результатах
   - RRF включен по умолчанию (`_use_rrf = True`, `_rrf_k = 60`)

## Приоритетные задачи

### 1. Настроить Qdrant для векторного поиска ✅ (Выполнено)

**Цель:** Включить семантический поиск для нахождения релевантных записей по смыслу

**Шаги:**

1. **Проверить наличие Qdrant в docker-compose**
   ```bash
   # Проверить docker-compose.mcp.yml
   cat ../../infra/docker-compose.mcp.yml | grep -i qdrant
   ```

2. **Добавить Qdrant в docker-compose (если отсутствует)**
   ```yaml
   qdrant:
     image: qdrant/qdrant:latest
     ports:
       - "6333:6333"
       - "6334:6334"
     volumes:
       - qdrant_storage:/qdrant/storage
     environment:
       - QDRANT__SERVICE__GRPC_PORT=6334
   ```

3. **Установить переменную окружения**
   ```bash
   # В .env или docker-compose
   MEMORY_MCP_QDRANT_URL=http://qdrant:6333
   # Или для локальной разработки
   MEMORY_MCP_QDRANT_URL=http://localhost:6333
   ```

4. **Проверить подключение**
   ```python
   from memory_mcp.memory.vector_store import build_vector_store_from_env
   store = build_vector_store_from_env()
   print(f"Qdrant доступен: {store.available() if store else False}")
   ```

5. **Убедиться, что эмбеддинги сохраняются в Qdrant**
   - Проверить метод `ingest` в `adapters.py`
   - Убедиться, что `vector_store.upsert` вызывается

6. **Протестировать векторный поиск**
   ```python
   # Тест семантического поиска
   search_req = SearchRequest(query="финансовые вопросы", top_k=10)
   result = adapter.search(search_req)
   # Проверить, что результаты релевантны
   ```

**Ожидаемый результат:**
- Семантический поиск находит релевантные записи по смыслу
- Запросы типа "Сбер снижает ставки" находят записи про ипотеку
- Релевантность улучшается на 20-30%

**Время:** 1-2 часа

---

### 2. Улучшить гибридный поиск ✅ (Выполнено)

**Цель:** Оптимизировать объединение результатов из разных источников

**Шаги:**

1. **Реализовать Reciprocal Rank Fusion (RRF)**
   ```python
   # В adapters.py, метод search()
   def _reciprocal_rank_fusion(self, results_list: List[List[SearchResultItem]], k: int = 60):
       """Объединяет результаты из разных источников используя RRF."""
       scores = {}
       for results in results_list:
           for rank, item in enumerate(results, 1):
               score = 1.0 / (k + rank)
               scores[item.record_id] = scores.get(item.record_id, 0) + score
       return sorted(scores.items(), key=lambda x: x[1], reverse=True)
   ```

2. **Добавить boost для точных совпадений**
   ```python
   # Boost для записей, где все слова запроса найдены
   if all(word in item.content.lower() for word in query_words):
       item.score *= 1.2  # 20% boost
   ```

3. **Улучшить нормализацию scores**
   - Нормализовать scores из разных источников к [0, 1]
   - Учитывать распределение scores для лучшего ранжирования

4. **Протестировать на реальных запросах**
   - Сравнить результаты до и после улучшений
   - Измерить Precision@10 и Recall@10

**Ожидаемый результат:**
- Более точное ранжирование результатов
- Лучшее объединение FTS5 и векторного поиска
- Улучшение релевантности на 10-15%

**Время:** 2-3 часа

---

### 3. Улучшить обработку запросов ✅ (Выполнено 2025-11-18)

**Цель:** Увеличить количество запросов, которые находят релевантные записи

**Выполнено:**

1. ✅ **Реализована гибкая логика поиска**
   - Для коротких запросов (<=3 слова): используется строгая AND логика
   - Для длинных запросов (>3 слова): первые 2 слова через AND (обязательные), остальные через OR (опциональные)
   - Это позволяет находить релевантные записи даже если некоторые слова отсутствуют

2. ✅ **Улучшена фильтрация стоп-слов**
   - Используется готовый список стоп-слов из `russian_tokenizer.py` (STOP_WORDS)
   - Удален дублирующий список стоп-слов из `typed_graph.py`

**Примеры работы:**

- Короткий запрос: `"сбер ипотека"` → `"сбер" AND "ипотека"` (оба слова обязательны)
- Длинный запрос: `"сбер снижает ставки семейная ипотека"` → `("сбер" AND "снижает") AND ("ставки" OR "семейная" OR "ипотека")` (первые 2 обязательны, остальные опциональны)

**Ожидаемый результат:**
- Больше запросов находят релевантные записи
- Улучшение Recall на 10-15% для длинных запросов

**Дополнительные улучшения (опционально):**
- Добавить синонимы для часто используемых слов
- Протестировать на проблемных запросах из отчета

---

## Дополнительные задачи

### 4. Тестирование и валидация

**Шаги:**

1. **Создать набор тестовых запросов**
   ```python
   TEST_QUERIES = [
       ("собрать такие красные листочки", "semya-old-S0014-M0109"),
       ("Сбер снижает ставки семейная ипотека", "semya-old-S0009-T02"),
       # ...
   ]
   ```

2. **Измерить метрики качества**
   - Precision@10
   - Recall@10
   - NDCG@10
   - MRR

3. **Сравнить результаты до и после улучшений**

**Время:** 1-2 часа

---

### 5. Документация и мониторинг

**Шаги:**

1. **Обновить документацию**
   - Описать настройку Qdrant
   - Добавить примеры использования
   - Обновить AGENTS.md

2. **Добавить метрики в health check**
   ```python
   # В health endpoint
   {
       "qdrant_available": store.available(),
       "embeddings_coverage": calculate_coverage(),
       "search_quality": calculate_quality_metrics(),
   }
   ```

**Время:** 1 час

---

## Рекомендуемый порядок выполнения

1. ✅ **Настроить Qdrant** (выполнено 2025-11-18)
2. ✅ **Улучшить гибридный поиск** (выполнено 2025-11-18)
3. ✅ **Улучшить обработку запросов** (выполнено 2025-11-18)
4. **Потом:** Тестирование и валидация (создать тестовый набор, измерить метрики)

## Ожидаемые результаты после всех улучшений

- **Семантический поиск:** Работает, находит релевантные записи по смыслу
- **Релевантность:** Улучшение на 40-50% по сравнению с текущим состоянием
- **Покрытие:** 90%+ запросов находят релевантные записи
- **Ранжирование:** Точное, релевантные результаты в топе

## Быстрый старт

Для начала работы с Qdrant:

```bash
# 1. Проверить docker-compose
cd ../../infra
cat docker-compose.mcp.yml | grep -A 10 qdrant

# 2. Если Qdrant отсутствует, добавить (см. шаг 1.2 выше)

# 3. Запустить Qdrant
docker-compose -f docker-compose.mcp.yml up -d qdrant

# 4. Установить переменную окружения
export MEMORY_MCP_QDRANT_URL=http://localhost:6333

# 5. Перезапустить memory-mcp
docker-compose -f docker-compose.mcp.yml restart memory-mcp

# 6. Проверить подключение
curl http://localhost:6333/health
```

## Полезные команды

```bash
# Проверить статус Qdrant
curl http://localhost:6333/collections

# Проверить коллекции в Qdrant
curl http://localhost:6333/collections/memory-records

# Проверить логи memory-mcp
docker-compose -f ../../infra/docker-compose.mcp.yml logs -f memory-mcp

# Тестировать поиск
python -c "
from memory_mcp.mcp.adapters import MemoryServiceAdapter
from memory_mcp.mcp.schema import SearchRequest
adapter = MemoryServiceAdapter()
result = adapter.search(SearchRequest(query='тест', top_k=5))
print(f'Найдено: {len(result.results)}')
"
```

